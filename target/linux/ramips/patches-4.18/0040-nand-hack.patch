--- a/drivers/mtd/nand/raw/nand_base.c
+++ b/drivers/mtd/nand/raw/nand_base.c
@@ -3567,6 +3567,9 @@ static int nand_do_read_ops(struct mtd_i
 						 __func__, buf);
 
 read_retry:
+#ifdef CONFIG_MTK_MTD_NAND
+			ret = chip->read_page(mtd, chip, bufpoi, page);
+#else
 			/*
 			 * Now read the page into the buffer.  Absent an error,
 			 * the read methods return max bitflips per ecc step.
@@ -3583,6 +3586,7 @@ read_retry:
 			else
 				ret = chip->ecc.read_page(mtd, chip, bufpoi,
 							  oob_required, page);
+#endif
 			if (ret < 0) {
 				if (use_bufpoi)
 					/* Invalidate page cache */
@@ -4448,9 +4452,14 @@ static int nand_do_write_ops(struct mtd_
 			memset(chip->oob_poi, 0xff, mtd->oobsize);
 		}
 
-		ret = nand_write_page(mtd, chip, column, bytes, wbuf,
-				      oob_required, page,
-				      (ops->mode == MTD_OPS_RAW));
+		if (chip->write_page)
+			ret = chip->write_page(mtd, chip, column, bytes, wbuf,
+					       oob_required, page,
+					       (ops->mode == MTD_OPS_RAW));
+		else
+			ret = nand_write_page(mtd, chip, column, bytes, wbuf,
+					      oob_required, page,
+					      (ops->mode == MTD_OPS_RAW));
 		if (ret)
 			break;
 
--- a/include/linux/mtd/rawnand.h
+++ b/include/linux/mtd/rawnand.h
@@ -1272,6 +1272,9 @@ struct nand_chip {
 		       bool check_only);
 	int (*erase)(struct mtd_info *mtd, int page);
 	int (*scan_bbt)(struct mtd_info *mtd);
+	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
+			uint32_t offset, int data_len, const uint8_t *buf,
+			int oob_required, int page, int raw);
 	int (*set_features)(struct mtd_info *mtd, struct nand_chip *chip,
 			    int feature_addr, uint8_t *subfeature_para);
 	int (*get_features)(struct mtd_info *mtd, struct nand_chip *chip,
@@ -1408,6 +1411,9 @@ static inline void *nand_get_manufacture
 #define NAND_MFR_ATO		0x9b
 #define NAND_MFR_WINBOND	0xef
 
+#ifdef CONFIG_MTK_MTD_NAND
+	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip, u8 *buf, int page);
+#endif /* CONFIG_MTK_MTD_NAND */
 
 /*
  * A helper for defining older NAND chips where the second ID byte fully
